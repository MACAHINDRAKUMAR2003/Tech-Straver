# -*- coding: utf-8 -*-
"""House_Price_Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tHfdF_UcvxVx_WwB7pvvFibrPOayDw35
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

data_path = '/content/archive (31).zip'
df = pd.read_csv(data_path)
df

#Showing the first 5 items of dataset
# Display the first few rows of the dataframe
print("First few rows of the dataset:")
print(df.head())

#Summary of the datset using describe method
# Get a summary of the dataset
print("\nSummary of the dataset:")
df.describe()

#Information about th datset
# Get information about the dataset
print("\nInformation about the dataset:")
df.info()

# Check for missing values
print("\nMissing values in the dataset:")
df.isnull().sum()

# Distribution of house prices
plt.figure(figsize=(10, 6))
sns.histplot(df['price'],kde=True, bins=30)
plt.title('Distribution of House Prices')
plt.xlabel('Price')
plt.ylabel('Frequency')
plt.show()

# price vs area

from matplotlib import pyplot as plt
df.plot(kind='scatter', x='price', y='area', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

#price vs area
plt.figure(figsize=(10, 6))
plt.scatter(df['area'], df['price'], c=df['bedrooms'], cmap='viridis')
plt.xlabel('Area')
plt.ylabel('Price')
plt.title('Price vs Area by Number of Bedrooms')

#box plot representation on impact of Main Road Acess on House Price
plt.figure(figsize=(8, 5))
sns.boxplot(data=df, x='mainroad', y='price')
plt.xlabel('Main Road Access')
plt.ylabel('Price')
_ = plt.title('Impact of Main Road Access on House Price')

#mainroad vs price
figsize = (12, 2.5 * len(df['mainroad'].unique()))
plt.figure(figsize=figsize)

# Remove unnecessary spines
sns.despine(top=True, right=True, bottom=True, left=True)

plt.title('Main Road vs Price')
plt.xlabel('Main Road')
plt.ylabel('Price')

# Remove unnecessary spines
sns.despine(top=True, right=True, bottom=True, left=True)

plt.title('Main Road vs Price')
plt.xlabel('Main Road')
plt.ylabel('Price')

# Handle missing values (if any)
df = df.dropna()

# Encode categorical variables
label_encoders = {}
for column in df.select_dtypes(include=['object']).columns:
    label_encoders[column] = LabelEncoder()
    df[column] = label_encoders[column].fit_transform(df[column])
print(df.head())

# Separate features (X) and target (y)
X = df.drop('price', axis=1)
y = df['price']
print(X)
y

# Split the dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Standardize the features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Correlation heatmap
plt.figure(figsize=(12, 5))
sns.heatmap(df.corr(), annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Correlation Heatmap')
plt.show()

# Train a Linear Regression model
model = LinearRegression()
model.fit(X_train_scaled, y_train)

#Make predictions on the test set
y_pred = model.predict(X_test_scaled)

# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
print(f'Mean Squared Error: {mse:.2f}')
print(f'R-squared: {r2:.2f}')

# Scatter plot for Actual vs Predicted Prices
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred, alpha=0.7)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')
plt.xlabel('Actual Prices')
plt.ylabel('Predicted Prices')
plt.title('Actual vs Predicted Prices')
plt.show()

# Residual plot
residuals = y_test - y_pred
plt.figure(figsize=(10, 6))
plt.scatter(y_pred, residuals, alpha=0.7)
plt.axhline(y=0, color='r', linestyle='--')
plt.xlabel('Predicted Prices')
plt.ylabel('Residuals')
plt.title('Residual Plot')
plt.show()

# Coefficients of the model
coefficients = pd.Series(model.coef_, index=X.columns)

# Bar plot of feature importances
plt.figure(figsize=(12, 8))
coefficients.sort_values().plot(kind='barh')
plt.title('Feature Importances')
plt.show()

# Predict price for new data
new_data = pd.DataFrame([[1000, 3, 2, 2, 'yes', 'no', 'no', 'no', 'yes', 2, 'yes', 'furnished', 15.969910, 17.597960]],
                         columns=['area', 'bedrooms', 'bathrooms', 'stories', 'mainroad', 'guestroom', 'basement', 'hotwaterheating',
                                  'airconditioning', 'parking', 'prefarea', 'furnishingstatus', 'LATITUDE', 'LONGITUDE'])

# Ensure the new data has the same columns and order as the training data
new_data = new_data[X.columns]

# Encode new data
for column in new_data.select_dtypes(include=['object']).columns:
    if column in label_encoders:
        new_data[column] = label_encoders[column].transform(new_data[column])
    else:
        raise KeyError(f"Column '{column}' not found in label_encoders. Ensure it exists in the training data.")

# Standardize new data
new_data_scaled = scaler.transform(new_data)

# Predict the price
predicted_price = model.predict(new_data_scaled)
print(f'Predicted Price for the new data: {predicted_price[0]:.2f}')